
proc buildAttrTree(string $nodeName, string $attr)
{
    if ($attr == "input")
        return;

    string $fullAttrName = $nodeName + "." + $attr;
    string $type = `getAttr -type $fullAttrName`;
    string $children[] = `attributeQuery -n $nodeName -lc $attr`;
    string $niceName = `attributeQuery -n $nodeName -nn $attr`;

    if ("TdataCompound" != $type)
    {
		if ($type == "" )
		{
			editorTemplate -suppress $attr;
		}
        else if ("Separator" == $niceName)
        {
            editorTemplate -addSeparator;
        } else
        {
            editorTemplate -addDynamicControl $attr;
        }
        return;
    }

    editorTemplate -beginLayout $niceName -collapse true;
    for ($i=0; $i<size($children); $i++)
    {
        string $child = $children[$i];
        buildAttrTree($nodeName, $child);
    }
    editorTemplate -endLayout;
}

proc string[] getValidAssetInputs(string $objects[])
{
    int $validInputsCount = 0;
    string $validAssetInputs[];

    for($object in $objects)
    {
	int $found = 0;

	// check if the object is a supported node
	if(!$found)
	{
	    if(`nodeType $object` == "mesh")
	    {
		$validAssetInputs[$validInputsCount++] = $object;
		$found = 1;
	    }
	}

	// check if there are any supported nodes in immediate children
	if(!$found)
	{
	    string $tempObjects[] = `listRelatives -shapes -type "mesh" $object`;
	    if(size($tempObjects))
	    {
		for($tempObject in $tempObjects)
		{
		    $validAssetInputs[$validInputsCount++] = $tempObject;
		}
		$found = 1;
	    }
	}
    }

    return $validAssetInputs;
}

global proc AEhoudiniAssetSetInputToSelection(string $inputAttr)
{
    string $validInputs[];
    
    string $selection[] = `ls -selection`;

    // make sure we don't include the houdiniAsset node itself if it's selected last
    if(size($selection))
    {
	int $lastSelectionIndex = size($selection) - 1;
	if(plugNode($inputAttr) == $selection[$lastSelectionIndex])
	{
	    stringArrayRemoveAtIndex($lastSelectionIndex, $selection);
	}
    }

    if(size($selection) > 0)
    {
	if(size($selection) > 1)
	{
	    error("Please select exactly one object to be used for input.");
	}

	$validInputs = getValidAssetInputs($selection);
	if(size($validInputs) > 1)
	{
	    error("Selection contains multiple supported objects. Please select exactly one object to be used for input.");
	}
	else if(size($validInputs) == 0)
	{
	    error("Selection has no supported object that can be used for input.");
	}
    }
    else
    {
	// AEhoudiniAssetSetInput is also used for disconnecting when string is empty
	$validInputs[0] = "";
    }

    AEhoudiniAssetSetInput($inputAttr, $validInputs[0]);
}

global proc AEhoudiniAssetSetInputToText(string $textField, string $inputAttr)
{    
    string $validInputs[];

    string $str = `textField -q -text $textField`;
    if($str != "")
    {
	if(!`objExists $str`)
	{
	    error("Entered object doesn't exist.");
	}

	$validInputs = getValidAssetInputs({$str});
	if(size($validInputs) > 1)
	{
	    error("Entered object contains multiple supported objects. Please enter the exact object to be used for input.");
	}
	else if(size($validInputs) == 0)
	{
	    error("Entered object has no supported object that can be used for input.");
	}
    }
    else
    {
	// AEhoudiniAssetSetInput is also used for disconnecting when string is empty
	$validInputs[0] = "";
    }

    AEhoudiniAssetSetInput($inputAttr, $validInputs[0]);
}

global proc AEhoudiniAssetSetInput(string $inputAttr, string $str)
{
    string $inputTransformAttr = $inputAttr + ".inputTransform";
    string $inputGeoAttr = $inputAttr + ".inputGeo";
    if ($str == "")
    {
        // remove input if cleared
        string $inPlug = `connectionInfo -sfd $inputGeoAttr`;
        string $inTransformPlug = `connectionInfo -sfd $inputTransformAttr`;
        if ($inPlug != "")
        {
            disconnectAttr $inPlug $inputGeoAttr;
            disconnectAttr $inTransformPlug $inputTransformAttr;
            //string $inMesh = plugNode($inPlug);
            //showHidden $inMesh;
        }
    } else
    {       
        
        // connect new input
        if (`objExists $str`)
	{            
            if(`nodeType $str` == "houdiniAsset")
            {                
                //If they just type the name of a houdini asset, we'll hook it up assuming the 1st output
                string $outputMeshPlug = $str + ".output.outputObjects[0].outputObjectMesh";
                string $outputMeshConn[] = `listConnections -s 0 -d 1 $outputMeshPlug`;
                if( size($outputMeshConn) > 0 )
                {
                    connectAttr -force ($str + ".output.outputObjects[0].outputObjectMetaData") $inputGeoAttr;
                    connectAttr -force ($str + ".wm[0]") $inputTransformAttr;
                }
                else
                {
                    error("Couldn't find mesh output on the asset.\n");
                }
            }
            else if (`nodeType $str` == "mesh")
            {

	        string $histPlug = `connectionInfo -sfd ($str + ".inMesh")`;
	        string $histNode = plugNode($histPlug);
            
	        if ($histNode != ""
		        && `nodeType $histNode` == "houdiniAsset")
	        {
		    // TODO: Assume that assets with inputs are SOPs
		    // *** A bit of a hack, plugNode just takes a substring of 
		    // everything before the first '.', even if the substring is
		    // not a node.
		    string $obj = plugNode(plugAttr($histPlug));                    

		    connectAttr -force ($histNode + "." + $obj + ".outputObjectMetaData") $inputGeoAttr;
                    connectAttr -force ($histNode + ".wm[0]") $inputTransformAttr;
	        }
	        else 
	        {
		    connectAttr -force ($str + ".outMesh") $inputGeoAttr;
                    string $parent[] = `listRelatives -parent $str`;
                    if( size($parent) > 0 && `nodeType $parent[0]` == "transform" )
                    {
                        string $parentWorldMatrixPlug = $parent[0] + ".wm[0]";
                        connectAttr -force $parentWorldMatrixPlug $inputTransformAttr;
                    }
		    //hide $str;
	        }            
            }
            else
            {
                error("Please input the name of a mesh or houdini asset.\n");
            }
	}
        
    }
}

global proc AEhoudiniAssetInputsNew(string $inputsAttribute)
{
    columnLayout -adj true "inputsLayout";
    setParent ..;

    AEhoudiniAssetInputsReplace $inputsAttribute;
}


global proc AEhoudiniAssetInputsReplace(string $inputsAttribute)
{
    string $parent = `setParent -q`;
    string $inputsLayoutFull = $parent + "|inputsLayout";

    if(`layout -q -numberOfChildren $inputsLayoutFull`)
    {
	for($child in `layout -q -childArray $inputsLayoutFull`)
	{
	    deleteUI ($inputsLayoutFull + "|" + $child);
	}
    }

    setParent $inputsLayoutFull;

    int $multiIndices[] = `getAttr -multiIndices $inputsAttribute`;
    for($i=0; $i < size($multiIndices); $i++)
    {
        int $index = $multiIndices[$i];
	string $inputAttribute = $inputsAttribute + "[" + $index + "]";

        string $inputLayout = "input" + ($index + 1) + "Layout";
	string $inputLayoutFull = $inputsLayoutFull + "|" + $inputLayout;
	rowLayout
	    -numberOfColumns 3
            -columnWidth3 50 150 50
            -adjustableColumn 2
            -columnAlign  1 "right"
            -columnAttach 1 "both"     2
            -columnAttach 2 "both"  2
            -columnAttach 3 "left"  2
	    $inputLayout;

            text -label ("Input " + ($index + 1));
            string $inputTextFieldFull = ($inputLayoutFull + "|inputTextField");
	    textField
		-alwaysInvokeEnterCommandOnReturn true
		-enterCommand ("AEhoudiniAssetSetInputToText \"" + $inputTextFieldFull + "\" \""
		 + $inputAttribute + "\"")
		"inputTextField";
            button
		-label "Set to Selection"
                -command ("AEhoudiniAssetSetInputToSelection \"" + $inputAttribute + "\"");

	setParent ..;

	scriptJob
	    -parent $inputLayoutFull
	    -replacePrevious
	    -attributeChange ($inputAttribute + ".inputGeo")
	    ("AEhoudiniAssetUpdateInput \"" + $inputLayoutFull + "\" \"" + $inputAttribute + "\"");

	scriptJob
	    -parent $inputLayoutFull
	    -replacePrevious
	    -attributeChange ($inputAttribute + ".inputTransform")
	    ("AEhoudiniAssetUpdateInput \"" + $inputLayoutFull + "\" \"" + $inputAttribute + "\"");

	AEhoudiniAssetUpdateInput $inputLayoutFull $inputAttribute;
    }

    setParent ..;
}

global proc AEhoudiniAssetUpdateInput(string $inputLayout, string $inputAttribute)
{
    string $inputTextField = $inputLayout + "|inputTextField";

    // set the appropriate text
    string $connectedMeshAttr = `connectionInfo -sourceFromDestination ($inputAttribute + ".inputGeo")`;
    string $connectedMesh = plugNode($connectedMeshAttr);
    textField -edit -text $connectedMesh $inputTextField;
}

global proc AEhoudiniAssetTemplate( string $nodeName )
{
    
    editorTemplate -beginScrollLayout;
    editorTemplate -addExtraControls;
    

    editorTemplate -addControl "assetPath";

    // special ui for inputs
    string $inputAttrArray[] = `listAttr -st "input" $nodeName`;
    string $inputAttr = $inputAttrArray[0];
    if ($inputAttr != "")
    {
        editorTemplate -beginLayout "Inputs" -collapse false;
        editorTemplate -callCustom "AEhoudiniAssetInputsNew" "AEhoudiniAssetInputsReplace"
            $inputAttr;
       
        editorTemplate -endLayout;
    }


    // get list of attributes
    string $attrs[] = `listAttr -ud $nodeName`;

    for ($i=0; $i<size($attrs); $i++)
    {
        string $attr = $attrs[$i];
        string $parents[] = `attributeQuery -n $nodeName -lp $attr`;
        if ((0 == size($parents)) && $attr != "input")
        {
            buildAttrTree($nodeName, $attr);
        }
        editorTemplate -suppress $attr;
    }

    editorTemplate -endLayout;

    editorTemplate -suppress "caching";
    editorTemplate -suppress "nodeState";



}

