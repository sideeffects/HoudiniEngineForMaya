proc buildAttrTree(string $nodeName, string $attr, string $fullAttr)
{
    string $fullAttrName = $nodeName + "." + $fullAttr;

    // Using for-in loop with the attributeQuery result directly crashes Maya.
    // This is most likely a MEL bug. Workaround it by first storing the result
    // into a string array.
    //for($child in `attributeQuery
    //    -node $nodeName
    //    -listChildren $attr`)
    string $children[] = `attributeQuery -node $nodeName -listChildren $attr`;
    for($child in $children)
    {
        string $type = `getAttr -type ($fullAttrName + "." + $child)`;
        int $isCompound = ($type == "TdataCompound");
        int $isMulti = `attributeQuery -node $nodeName -multi $child`;

        string $multiparm_suffix = "__multiSize";
        int $isMultiSize = endsWith($child, $multiparm_suffix);

        // separator
        if($type == ""
                && `attributeQuery -node $nodeName -niceName $child` == "Separator")
        {
            separator;
        }
        // simple attributes
        else if(`attrControlGrp -q -handlesAttribute ($fullAttrName + "." + $child)`
                && !$isMultiSize)
        {
            attrControlGrp -attribute ($fullAttrName + "." + $child);
        }
        // a folder is represented by a compound attribute
        else if($isCompound && !$isMulti)
        {
            string $niceName = `attributeQuery -node $nodeName -niceName $child`;

            frameLayout
                -collapsable true
                -label $niceName;
            columnLayout
                -adjustableColumn 1;

            buildAttrTree($nodeName, $child, $fullAttr + "." + $child);

            setParent ..;
            setParent ..;
        }
        // a multiparm is represented by a "multiSize" attribute and a multi compound attribute
        else if($isCompound && $isMulti)
        {
            // the actual UI for the multiparm attribute is generated when checking "multiSize"
        }
        else if($isMultiSize)
        {
            string $multiAttr = substring($child, 1, size($child) - size($multiparm_suffix));
            string $multiFullAttr = $fullAttr + "." + $multiAttr;

            string $multiNiceName = `attributeQuery -node $nodeName -niceName $child`;

            frameLayout
                -collapsable true
                -label $multiNiceName;
            columnLayout
                -adjustableColumn 1;

            string $parent = `setParent -q`;

            // attributeEditorTemplate messes up layout, so pop out of it temporarily
            setUITemplate -popTemplate;

            rowLayout
                -numberOfColumns 3;

            attrControlGrp
                -attribute ($fullAttrName + "." + $child)
                -changeCommand ("houdiniAssetAdjustMulti \\\"" + $parent + "\\\" \\\"" + $nodeName + "\\\" \\\"" + $multiAttr + "\\\" \\\"" + $multiFullAttr + "\\\"");
            ;

            button
                -label "+"
                -width 30
                -command ("setAttr " + $fullAttrName + "." + $child
                        + " (`getAttr " + $fullAttrName + "." + $child + "` + 1)");
            button
                -label "-"
                -width 30
                -command ("setAttr " + $fullAttrName + "." + $child
                        + " (`getAttr " + $fullAttrName + "." + $child + "` - 1)");

            setParent ..;

            setUITemplate -pushTemplate attributeEditorTemplate;

            houdiniAssetAdjustMulti($parent, $nodeName, $multiAttr, $multiFullAttr);

            setParent ..;
            setParent ..;
        }
        else
        {
            buildAttrTree($nodeName, $child, $fullAttr + "." + $child);
        }
    }
}

global proc houdiniAssetAdjustMulti(
	string $parent,
	string $nodeName,
	string $attr,
	string $fullAttr
	)
{
    setParent $parent;

    setUITemplate -pushTemplate attributeEditorTemplate;

    string $fullAttrName = $nodeName + "." + $fullAttr;

    int $curMultiSize = (`layout -q -numberOfChildren $parent` - 1);
    int $multiSize = `getAttr ($fullAttrName + "__multiSize")`;

    if(`attributeQuery -node $nodeName -exists $attr`)
    {
        string $children[] = `attributeQuery -node $nodeName -listChildren $attr`;
        //TODO: child attributes aren't created when the size is 0

        for($i = $curMultiSize; $i < $multiSize; $i++)
        {
            // Wrap UI for each instance under one layout so that we have a known
            // number of children.
            columnLayout
                -adjustableColumn true;

            separator;

            text
                -align "left"
                -label $i;

            string $elementAttr = $fullAttr + "[" + $i + "]";

            buildAttrTree($nodeName, $attr, $elementAttr);

            setParent ..;
        }
    }

    string $layoutChildArray[] = `layout -q -childArray $parent`;
    for($i = $curMultiSize; $i-- > $multiSize; )
    {
        deleteUI $layoutChildArray[$i + 1];
    }

    setUITemplate -popTemplate;
}

proc string[] getValidAssetInputs(string $objects[])
{
    string $supportedTypes[] = {
	"houdiniAsset",
	"mesh",
	"nurbsCurve"
    };

    int $validInputsCount = 0;
    string $validAssetInputs[];

    for($object in $objects)
    {
	int $found = 0;

	// check if the object is a supported node
	if(!$found)
	{
	    int $isSupported = 0;

	    for($supportedType in $supportedTypes)
	    {
		if(`objectType -isAType $supportedType $object`)
		{
		    $isSupported = 1;
		    break;
		}
	    }

	    if($isSupported)
	    {
		$validAssetInputs[$validInputsCount++] = $object;
		$found = 1;
	    }
	}

	// check if there are any supported nodes in immediate children
	if(!$found)
	{
	    string $tempObjects[] = `listRelatives
		-fullPath
		-shapes
		-noIntermediate
		-type "mesh"
		-type "nurbsCurve"
		$object`;
	    if(size($tempObjects))
	    {
		for($tempObject in $tempObjects)
		{
		    $validAssetInputs[$validInputsCount++] = $tempObject;
		}
		$found = 1;
	    }
	}
    }

    return $validAssetInputs;
}

proc clearInput(string $inputAttr)
{
    string $inputTransformAttr = $inputAttr + ".inputTransform";
    string $inputGeoAttr = $inputAttr + ".inputGeo";

    // remove input if cleared
    string $inPlug = `connectionInfo -sfd $inputGeoAttr`;
    string $inTransformPlug = `connectionInfo -sfd $inputTransformAttr`;
    if ($inPlug != "")
    {
	disconnectAttr $inPlug $inputGeoAttr;
	disconnectAttr $inTransformPlug $inputTransformAttr;
	//string $inMesh = plugNode($inPlug);
	//showHidden $inMesh;
    }
}

proc setInput(string $inputAttr, string $object)
{
    string $inputTransformAttr = $inputAttr + ".inputTransform";
    string $inputGeoAttr = $inputAttr + ".inputGeo";

    if(`objectType -isAType "houdiniAsset" $object`)
    {
	// if we just got the houdiniAsset, just assume the first output
	connectAttr -force ($object + ".output.outputObjects[0].outputObjectMetaData") $inputGeoAttr;
	connectAttr -force ($object + ".worldMatrix") $inputTransformAttr;
    }
    else if(`objectType -isAType "mesh" $object`)
    {
	string $histPlug = `connectionInfo -sfd ($object + ".inMesh")`;
	string $histNode = plugNode($histPlug);

	if ($histNode != ""
		&& `nodeType $histNode` == "houdiniAsset")
	{
	    // TODO: Assume that assets with inputs are SOPs
	    // *** A bit of a hack, plugNode just takes a substring of
	    // everything before the first '.', even if the substring is
	    // not a node.
	    string $obj = plugNode(plugAttr($histPlug));

	    connectAttr -force ($histNode + "." + $obj + ".outputObjectMetaData") $inputGeoAttr;
	    connectAttr -force ($histNode + ".worldMatrix") $inputTransformAttr;
	}
	else
	{
	    connectAttr -force ($object + ".outMesh") $inputGeoAttr;
	    string $parent[] = `listRelatives -fullPath -parent $object`;
	    if( size($parent) > 0 && `nodeType $parent[0]` == "transform" )
	    {
		string $parentWorldMatrixPlug = $parent[0] + ".worldMatrix";
		connectAttr -force $parentWorldMatrixPlug $inputTransformAttr;
	    }
	}
    }
    else if(`objectType -isAType "nurbsCurve" $object`)
    {
	connectAttr -force ($object + ".local") $inputGeoAttr;
	string $parent[] = `listRelatives -fullPath -parent $object`;
	if( size($parent) > 0 && `nodeType $parent[0]` == "transform" )
	{
	    string $parentWorldMatrixPlug = $parent[0] + ".worldMatrix";
	    connectAttr -force $parentWorldMatrixPlug $inputTransformAttr;
	}
    }
    else
    {
	error("Cannot handle object:" + $object + "\n");
    }
}

global proc
AEhoudiniAssetOperationNew(string $attr)
{
    rowLayout
	-numberOfColumns 2;

	button -label "Sync"
	    syncButton;

	button -label "Reset Simulation"
	    resetSimulationButton;

    setParent ..;

    AEhoudiniAssetOperationReplace $attr;
}

global proc
AEhoudiniAssetOperationReplace(string $attr)
{
    string $nodeName = plugNode($attr);

    button -e
	-c ("houdiniAsset -sync " + $nodeName)
	syncButton;

    button -e
	-c ("houdiniAsset -resetSimulation " + $nodeName)
	resetSimulationButton;
}

global proc AEhoudiniAssetSetInputToSelection(string $inputAttr)
{
    string $validInputs[];
    
    string $selection[] = `ls -selection`;

    // make sure we don't include the houdiniAsset node itself if it's selected last
    if(size($selection))
    {
	int $lastSelectionIndex = size($selection) - 1;
	if(plugNode($inputAttr) == $selection[$lastSelectionIndex])
	{
	    stringArrayRemoveAtIndex($lastSelectionIndex, $selection);
	}
    }

    if(size($selection) == 0)
    {
	clearInput($inputAttr);
	return;
    }
    else if(size($selection) > 1)
    {
	error("Please select exactly one object to be used for input.");
    }

    $validInputs = getValidAssetInputs($selection);
    if(size($validInputs) > 1)
    {
	error("Selection contains multiple supported objects. Please select exactly one object to be used for input.");
    }
    else if(size($validInputs) == 0)
    {
	error("Selection has no supported object that can be used for input.");
    }

    setInput($inputAttr, $validInputs[0]);
}

global proc AEhoudiniAssetSetInputToText(string $textField, string $inputAttr)
{    
    string $validInputs[];

    string $str = `textField -q -text $textField`;
    if($str == "")
    {
	clearInput($inputAttr);
	return;
    }
    else if(!`objExists $str`)
    {
	error("Entered object doesn't exist.");
    }

    $validInputs = getValidAssetInputs({$str});
    if(size($validInputs) > 1)
    {
	error("Entered object contains multiple supported objects. Please enter the exact object to be used for input.");
    }
    else if(size($validInputs) == 0)
    {
	error("Entered object has no supported object that can be used for input.");
    }

    setInput($inputAttr, $validInputs[0]);
}

global proc AEhoudiniAssetInputsNew(string $inputsAttribute)
{
    columnLayout -adj true "inputsLayout";
    setParent ..;

    AEhoudiniAssetInputsReplace $inputsAttribute;
}


global proc AEhoudiniAssetInputsReplace(string $inputsAttribute)
{
    string $parent = `setParent -q`;
    string $inputsLayoutFull = $parent + "|inputsLayout";

    if(`layout -q -numberOfChildren $inputsLayoutFull`)
    {
	for($child in `layout -q -childArray $inputsLayoutFull`)
	{
	    deleteUI ($inputsLayoutFull + "|" + $child);
	}
    }

    setParent $inputsLayoutFull;

    int $multiIndices[] = `getAttr -multiIndices $inputsAttribute`;
    for($i=0; $i < size($multiIndices); $i++)
    {
        int $index = $multiIndices[$i];
	string $inputAttribute = $inputsAttribute + "[" + $index + "]";

        string $inputLayout = "input" + ($index + 1) + "Layout";
	string $inputLayoutFull = $inputsLayoutFull + "|" + $inputLayout;
	rowLayout
	    -numberOfColumns 3
            -columnWidth3 50 150 50
            -adjustableColumn 2
            -columnAlign  1 "right"
            -columnAttach 1 "both"     2
            -columnAttach 2 "both"  2
            -columnAttach 3 "left"  2
	    $inputLayout;

            text -label ("Input " + ($index + 1));
            string $inputTextFieldFull = ($inputLayoutFull + "|inputTextField");
	    textField
		-alwaysInvokeEnterCommandOnReturn true
		-enterCommand ("AEhoudiniAssetSetInputToText \"" + $inputTextFieldFull + "\" \""
		 + $inputAttribute + "\"")
		"inputTextField";
            button
		-label "Set to Selection"
                -command ("AEhoudiniAssetSetInputToSelection \"" + $inputAttribute + "\"");

	setParent ..;

	scriptJob
	    -parent $inputLayoutFull
	    -replacePrevious
	    -attributeChange ($inputAttribute + ".inputGeo")
	    ("AEhoudiniAssetUpdateInput \"" + $inputLayoutFull + "\" \"" + $inputAttribute + "\"");

	scriptJob
	    -parent $inputLayoutFull
	    -replacePrevious
	    -attributeChange ($inputAttribute + ".inputTransform")
	    ("AEhoudiniAssetUpdateInput \"" + $inputLayoutFull + "\" \"" + $inputAttribute + "\"");

	AEhoudiniAssetUpdateInput $inputLayoutFull $inputAttribute;
    }

    setParent ..;
}

global proc AEhoudiniAssetUpdateInput(string $inputLayout, string $inputAttribute)
{
    string $inputTextField = $inputLayout + "|inputTextField";

    // set the appropriate text
    string $connectedMeshAttr = `connectionInfo -sourceFromDestination ($inputAttribute + ".inputGeo")`;
    string $connectedMesh = plugNode($connectedMeshAttr);
    textField -edit -text $connectedMesh $inputTextField;
}

global proc AEhoudiniAssetParmNew(string $houdiniAssetParmAttribute)
{
    columnLayout -adjustableColumn 1 "parmLayout";
    setParent ..;

    AEhoudiniAssetParmReplace $houdiniAssetParmAttribute;
}

global proc AEhoudiniAssetParmReplace(string $houdiniAssetParmAttribute)
{
    string $parent = `setParent -q`;
    string $parmLayoutFull = $parent + "|parmLayout";

    if(`layout -q -numberOfChildren $parmLayoutFull`)
    {
	for($child in `layout -q -childArray $parmLayoutFull`)
	{
	    deleteUI ($parmLayoutFull + "|" + $child);
	}
    }

    setParent $parmLayoutFull;

    string $nodeName = plugNode($houdiniAssetParmAttribute);
    string $attrName = plugAttr($houdiniAssetParmAttribute);

    if(`attributeQuery -node $nodeName -exists $attrName`)
    {
        buildAttrTree($nodeName, $attrName, $attrName);
    }
}

global proc AEhoudiniAssetTemplate( string $nodeName )
{
    editorTemplate -beginScrollLayout;

    editorTemplate -addControl "assetPath";

    editorTemplate -callCustom "AEhoudiniAssetOperationNew" "AEhoudiniAssetOperationReplace"
	"unused";

    // special ui for inputs
    string $inputAttrArray[] = `listAttr -st "input" $nodeName`;
    string $inputAttr = $inputAttrArray[0];
    if ($inputAttr != "")
    {
        editorTemplate -beginLayout "Inputs" -collapse false;
        editorTemplate -callCustom "AEhoudiniAssetInputsNew" "AEhoudiniAssetInputsReplace"
            $inputAttr;
       
        editorTemplate -endLayout;
    }

    editorTemplate -callCustom "AEhoudiniAssetParmNew" "AEhoudiniAssetParmReplace" "houdiniAssetParm";

    editorTemplate -beginLayout "Maya Transform Attributes";

    AEtransformMain $nodeName;
    AEtransformNoScroll $nodeName;

    editorTemplate -endLayout;

    editorTemplate -addExtraControls;

    editorTemplate -endLayout;
}

