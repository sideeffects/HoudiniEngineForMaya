proc buildAttrTree(string $nodeName, string $attr)
{
    string $fullAttrName = $nodeName + "." + $attr;
    string $type = `attributeQuery -node $nodeName -attributeType $attr`;
    string $niceName = `attributeQuery -node $nodeName -niceName $attr`;

    // separator
    if($type == "generic" && $niceName == "Separator")
    {
	separator;
	return;
    }

    // simple attributes
    if(`attrControlGrp -q -handlesAttribute $fullAttrName`)
    {
	attrControlGrp -attribute $fullAttrName;
        return;
    }

    // compound attributes
    frameLayout
	-collapsable true
	-label $niceName;
    columnLayout
	-adjustableColumn 1;


    // Using for-in loop with the attributeQuery result directly crashes Maya.
    // This is most likely a MEL bug. Workaround it by first storing the result
    // into a string array.
    //for($child in `attributeQuery
    //    -node $nodeName
    //    -listChildren $attr`)
    string $children[] = `attributeQuery -node $nodeName -listChildren $attr`;
    for($child in $children)
    {
        buildAttrTree($nodeName, $child);
    }

    setParent ..;
    setParent ..;
}

proc string[] getValidAssetInputs(string $objects[])
{
    string $supportedTypes[] = {
	"houdiniAsset",
	"mesh",
	"nurbsCurve"
    };

    int $validInputsCount = 0;
    string $validAssetInputs[];

    for($object in $objects)
    {
	int $found = 0;

	// check if the object is a supported node
	if(!$found)
	{
	    int $isSupported = 0;

	    for($supportedType in $supportedTypes)
	    {
		if(`objectType -isAType $supportedType $object`)
		{
		    $isSupported = 1;
		    break;
		}
	    }

	    if($isSupported)
	    {
		$validAssetInputs[$validInputsCount++] = $object;
		$found = 1;
	    }
	}

	// check if there are any supported nodes in immediate children
	if(!$found)
	{
	    string $tempObjects[] = `listRelatives
		-fullPath
		-shapes
		-noIntermediate
		-type "mesh"
		-type "nurbsCurve"
		$object`;
	    if(size($tempObjects))
	    {
		for($tempObject in $tempObjects)
		{
		    $validAssetInputs[$validInputsCount++] = $tempObject;
		}
		$found = 1;
	    }
	}
    }

    return $validAssetInputs;
}

proc clearInput(string $inputAttr)
{
    string $inputTransformAttr = $inputAttr + ".inputTransform";
    string $inputGeoAttr = $inputAttr + ".inputGeo";

    // remove input if cleared
    string $inPlug = `connectionInfo -sfd $inputGeoAttr`;
    string $inTransformPlug = `connectionInfo -sfd $inputTransformAttr`;
    if ($inPlug != "")
    {
	disconnectAttr $inPlug $inputGeoAttr;
	disconnectAttr $inTransformPlug $inputTransformAttr;
	//string $inMesh = plugNode($inPlug);
	//showHidden $inMesh;
    }
}

proc setInput(string $inputAttr, string $object)
{
    string $inputTransformAttr = $inputAttr + ".inputTransform";
    string $inputGeoAttr = $inputAttr + ".inputGeo";

    if(`objectType -isAType "houdiniAsset" $object`)
    {
	// if we just got the houdiniAsset, just assume the first output
	connectAttr -force ($object + ".output.outputObjects[0].outputObjectMetaData") $inputGeoAttr;
	connectAttr -force ($object + ".worldMatrix") $inputTransformAttr;
    }
    else if(`objectType -isAType "mesh" $object`)
    {
	string $histPlug = `connectionInfo -sfd ($object + ".inMesh")`;
	string $histNode = plugNode($histPlug);

	if ($histNode != ""
		&& `nodeType $histNode` == "houdiniAsset")
	{
	    // TODO: Assume that assets with inputs are SOPs
	    // *** A bit of a hack, plugNode just takes a substring of
	    // everything before the first '.', even if the substring is
	    // not a node.
	    string $obj = plugNode(plugAttr($histPlug));

	    connectAttr -force ($histNode + "." + $obj + ".outputObjectMetaData") $inputGeoAttr;
	    connectAttr -force ($histNode + ".worldMatrix") $inputTransformAttr;
	}
	else
	{
	    connectAttr -force ($object + ".outMesh") $inputGeoAttr;
	    string $parent[] = `listRelatives -fullPath -parent $object`;
	    if( size($parent) > 0 && `nodeType $parent[0]` == "transform" )
	    {
		string $parentWorldMatrixPlug = $parent[0] + ".worldMatrix";
		connectAttr -force $parentWorldMatrixPlug $inputTransformAttr;
	    }
	}
    }
    else if(`objectType -isAType "nurbsCurve" $object`)
    {
	connectAttr -force ($object + ".local") $inputGeoAttr;
	string $parent[] = `listRelatives -fullPath -parent $object`;
	if( size($parent) > 0 && `nodeType $parent[0]` == "transform" )
	{
	    string $parentWorldMatrixPlug = $parent[0] + ".worldMatrix";
	    connectAttr -force $parentWorldMatrixPlug $inputTransformAttr;
	}
    }
    else
    {
	error("Cannot handle object:" + $object + "\n");
    }
}

global proc
AEhoudiniAssetOperationNew(string $attr)
{
    rowLayout
	-numberOfColumns 2;

	button -label "Sync"
	    syncButton;

	button -label "Reset Simulation"
	    resetSimulationButton;

    setParent ..;

    AEhoudiniAssetOperationReplace $attr;
}

global proc
AEhoudiniAssetOperationReplace(string $attr)
{
    string $nodeName = plugNode($attr);

    button -e
	-c ("houdiniAsset -sync " + $nodeName)
	syncButton;

    button -e
	-c ("houdiniAsset -resetSimulation " + $nodeName)
	resetSimulationButton;
}

global proc AEhoudiniAssetSetInputToSelection(string $inputAttr)
{
    string $validInputs[];
    
    string $selection[] = `ls -selection`;

    // make sure we don't include the houdiniAsset node itself if it's selected last
    if(size($selection))
    {
	int $lastSelectionIndex = size($selection) - 1;
	if(plugNode($inputAttr) == $selection[$lastSelectionIndex])
	{
	    stringArrayRemoveAtIndex($lastSelectionIndex, $selection);
	}
    }

    if(size($selection) == 0)
    {
	clearInput($inputAttr);
	return;
    }
    else if(size($selection) > 1)
    {
	error("Please select exactly one object to be used for input.");
    }

    $validInputs = getValidAssetInputs($selection);
    if(size($validInputs) > 1)
    {
	error("Selection contains multiple supported objects. Please select exactly one object to be used for input.");
    }
    else if(size($validInputs) == 0)
    {
	error("Selection has no supported object that can be used for input.");
    }

    setInput($inputAttr, $validInputs[0]);
}

global proc AEhoudiniAssetSetInputToText(string $textField, string $inputAttr)
{    
    string $validInputs[];

    string $str = `textField -q -text $textField`;
    if($str == "")
    {
	clearInput($inputAttr);
	return;
    }
    else if(!`objExists $str`)
    {
	error("Entered object doesn't exist.");
    }

    $validInputs = getValidAssetInputs({$str});
    if(size($validInputs) > 1)
    {
	error("Entered object contains multiple supported objects. Please enter the exact object to be used for input.");
    }
    else if(size($validInputs) == 0)
    {
	error("Entered object has no supported object that can be used for input.");
    }

    setInput($inputAttr, $validInputs[0]);
}

global proc AEhoudiniAssetInputsNew(string $inputsAttribute)
{
    columnLayout -adj true "inputsLayout";
    setParent ..;

    AEhoudiniAssetInputsReplace $inputsAttribute;
}


global proc AEhoudiniAssetInputsReplace(string $inputsAttribute)
{
    string $parent = `setParent -q`;
    string $inputsLayoutFull = $parent + "|inputsLayout";

    if(`layout -q -numberOfChildren $inputsLayoutFull`)
    {
	for($child in `layout -q -childArray $inputsLayoutFull`)
	{
	    deleteUI ($inputsLayoutFull + "|" + $child);
	}
    }

    setParent $inputsLayoutFull;

    int $multiIndices[] = `getAttr -multiIndices $inputsAttribute`;
    for($i=0; $i < size($multiIndices); $i++)
    {
        int $index = $multiIndices[$i];
	string $inputAttribute = $inputsAttribute + "[" + $index + "]";

        string $inputLayout = "input" + ($index + 1) + "Layout";
	string $inputLayoutFull = $inputsLayoutFull + "|" + $inputLayout;
	rowLayout
	    -numberOfColumns 3
            -columnWidth3 50 150 50
            -adjustableColumn 2
            -columnAlign  1 "right"
            -columnAttach 1 "both"     2
            -columnAttach 2 "both"  2
            -columnAttach 3 "left"  2
	    $inputLayout;

            text -label ("Input " + ($index + 1));
            string $inputTextFieldFull = ($inputLayoutFull + "|inputTextField");
	    textField
		-alwaysInvokeEnterCommandOnReturn true
		-enterCommand ("AEhoudiniAssetSetInputToText \"" + $inputTextFieldFull + "\" \""
		 + $inputAttribute + "\"")
		"inputTextField";
            button
		-label "Set to Selection"
                -command ("AEhoudiniAssetSetInputToSelection \"" + $inputAttribute + "\"");

	setParent ..;

	scriptJob
	    -parent $inputLayoutFull
	    -replacePrevious
	    -attributeChange ($inputAttribute + ".inputGeo")
	    ("AEhoudiniAssetUpdateInput \"" + $inputLayoutFull + "\" \"" + $inputAttribute + "\"");

	scriptJob
	    -parent $inputLayoutFull
	    -replacePrevious
	    -attributeChange ($inputAttribute + ".inputTransform")
	    ("AEhoudiniAssetUpdateInput \"" + $inputLayoutFull + "\" \"" + $inputAttribute + "\"");

	AEhoudiniAssetUpdateInput $inputLayoutFull $inputAttribute;
    }

    setParent ..;
}

global proc AEhoudiniAssetUpdateInput(string $inputLayout, string $inputAttribute)
{
    string $inputTextField = $inputLayout + "|inputTextField";

    // set the appropriate text
    string $connectedMeshAttr = `connectionInfo -sourceFromDestination ($inputAttribute + ".inputGeo")`;
    string $connectedMesh = plugNode($connectedMeshAttr);
    textField -edit -text $connectedMesh $inputTextField;
}

global proc AEhoudiniAssetParmNew(string $houdiniAssetParmAttribute)
{
    columnLayout -adjustableColumn 1 "parmLayout";
    setParent ..;

    AEhoudiniAssetParmReplace $houdiniAssetParmAttribute;
}

global proc AEhoudiniAssetParmReplace(string $houdiniAssetParmAttribute)
{
    string $parent = `setParent -q`;
    string $parmLayoutFull = $parent + "|parmLayout";

    if(`layout -q -numberOfChildren $parmLayoutFull`)
    {
	for($child in `layout -q -childArray $parmLayoutFull`)
	{
	    deleteUI ($parmLayoutFull + "|" + $child);
	}
    }

    setParent $parmLayoutFull;

    string $nodeName = plugNode($houdiniAssetParmAttribute);
    string $attrName = plugAttr($houdiniAssetParmAttribute);

    for($attr in `attributeQuery -node $nodeName -listChildren $attrName`)
    {
	buildAttrTree($nodeName, $attr);
    }
}

global proc AEhoudiniAssetTemplate( string $nodeName )
{
    editorTemplate -beginScrollLayout;

    editorTemplate -addControl "assetPath";

    editorTemplate -callCustom "AEhoudiniAssetOperationNew" "AEhoudiniAssetOperationReplace"
	"unused";

    // special ui for inputs
    string $inputAttrArray[] = `listAttr -st "input" $nodeName`;
    string $inputAttr = $inputAttrArray[0];
    if ($inputAttr != "")
    {
        editorTemplate -beginLayout "Inputs" -collapse false;
        editorTemplate -callCustom "AEhoudiniAssetInputsNew" "AEhoudiniAssetInputsReplace"
            $inputAttr;
       
        editorTemplate -endLayout;
    }

    editorTemplate -callCustom "AEhoudiniAssetParmNew" "AEhoudiniAssetParmReplace" "houdiniAssetParm";

    editorTemplate -beginLayout "Maya Transform Attributes";

    AEtransformMain $nodeName;
    AEtransformNoScroll $nodeName;

    editorTemplate -endLayout;

    editorTemplate -addExtraControls;

    editorTemplate -endLayout;
}

